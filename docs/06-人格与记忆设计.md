# GraphMemory 人格与记忆设计

## 一、AstrBot 人格机制

### 1.1 人格 (Persona) 概念

在 AstrBot 中，**人格 (Persona)** 是一组 LLM 行为指令的集合，包括:

- **system_prompt**: 系统提示词，定义 AI 的角色和行为
- **begin_dialogs**: 预设对话，模拟对话开场
- **tools**: 可用工具列表

**示例**:
```python
# 人格1: 技术助手
Persona(
    persona_id="tech_assistant",
    system_prompt="你是一个专业的技术助手，擅长编程和系统架构。",
    begin_dialogs=["你好！", "你好！我是技术助手，有什么可以帮你的？"],
    tools=None  # 使用所有工具
)

# 人格2: 生活顾问
Persona(
    persona_id="life_advisor",
    system_prompt="你是一个温暖的生活顾问，擅长情感支持和生活建议。",
    begin_dialogs=["嗨~", "嗨~ 我是你的生活顾问，有什么烦恼吗？"],
    tools=[]  # 不使用工具
)
```

### 1.2 会话与对话的关系

AstrBot 中有两个重要概念:

- **会话 (Session)**: 聊天窗口，如 QQ 群 "123456789"
- **对话 (Conversation)**: 会话中的一次完整对话，有独立的历史记录

**关系**:
```
会话 (Session)
  ├── 对话1 (Conversation) - 使用人格A
  ├── 对话2 (Conversation) - 使用人格B
  └── 对话3 (Conversation) - 使用人格A
```

### 1.3 人格切换场景

#### 场景1: 创建新对话时切换人格
```
用户: /new tech_assistant
Bot: 已创建新对话，使用人格 "技术助手"

用户: 如何设计一个微服务架构？
Bot: (以技术助手的身份回答)

用户: /new life_advisor
Bot: 已创建新对话，使用人格 "生活顾问"

用户: 最近工作压力很大怎么办？
Bot: (以生活顾问的身份回答)
```

#### 场景2: 在同一对话中切换人格
```
用户: 如何设计一个微服务架构？
Bot: (以技术助手的身份回答)

用户: /persona life_advisor
Bot: 已切换到人格 "生活顾问"

用户: 最近工作压力很大怎么办？
Bot: (以生活顾问的身份回答)
```

### 1.4 数据库结构

**ConversationV2 表**:
```sql
CREATE TABLE conversations (
    conversation_id TEXT PRIMARY KEY,
    platform_id TEXT NOT NULL,
    user_id TEXT NOT NULL,
    content JSON,  -- 对话历史
    persona_id TEXT,  -- 关联的人格ID
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

**Persona 表**:
```sql
CREATE TABLE personas (
    persona_id TEXT PRIMARY KEY,
    system_prompt TEXT NOT NULL,
    begin_dialogs JSON,
    tools JSON,
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

## 二、旧版本插件的人格处理

### 2.1 设计意图

旧版本 (v0.2.0) 设计了人格隔离功能:

**配置项**:
```json
{
    "enable_persona_isolation": true,
    "persona_isolation_exceptions": []
}
```

**数据结构**:
- 缓冲区消息有 `persona_id` 字段
- 中期记忆有 `persona_id` 字段
- 支持检测人格切换并刷新缓冲区

### 2.2 实际实现

**问题**: 功能未真正实现

```python
# plugin_service.py:599
async def _get_persona_id(self, event: AstrMessageEvent) -> str:
    """返回默认人格ID，记忆仅按会话隔离。"""
    return self.DEFAULT_PERSONA_ID  # 总是返回 "default"
```

**结果**:
- 所有记忆都使用 "default" 人格
- 人格切换检测逻辑永远不会触发
- 人格隔离配置无效

### 2.3 为什么未实现

可能的原因:

1. **复杂度**: 人格隔离增加了系统复杂度
2. **需求不明确**: 不确定用户是否需要人格隔离
3. **实现困难**: 需要从 AstrBot 获取当前人格 ID

## 三、记忆共享策略分析

### 3.1 策略1: 完全隔离

**定义**: 不同人格拥有完全独立的记忆空间

**实现**:
- 所有节点和关系都关联 `persona_id`
- 检索时只查询当前人格的记忆

**示例**:
```
技术助手人格:
  - 实体: Python, Docker, 微服务
  - 关系: Python -> Docker (常用于容器化)

生活顾问人格:
  - 实体: 瑜伽, 冥想, 健康饮食
  - 关系: 瑜伽 -> 冥想 (有助于放松)
```

**优点**:
- 人格独立性强，适合角色扮演
- 不同人格的记忆不会混淆

**缺点**:
- 用户基本信息重复存储
- 记忆碎片化，缺乏连贯性
- 存储空间浪费

**适用场景**:
- 多用户共享同一个 Bot
- 严格的角色扮演场景

### 3.2 策略2: 完全共享

**定义**: 所有人格共享同一个记忆空间

**实现**:
- 节点和关系不关联 `persona_id`
- 所有人格都能访问所有记忆

**示例**:
```
共享记忆:
  - 实体: 张三, Python, 瑜伽
  - 关系: 张三 -> Python (擅长)
  - 关系: 张三 -> 瑜伽 (喜欢)

技术助手: 可以看到张三擅长 Python 和喜欢瑜伽
生活顾问: 可以看到张三擅长 Python 和喜欢瑜伽
```

**优点**:
- 记忆连贯，用户信息统一
- 存储空间节省
- 实现简单

**缺点**:
- 人格之间没有隔离
- 可能出现上下文混淆

**适用场景**:
- 单用户使用
- 人格只是改变回答风格，不改变知识范围

### 3.3 策略3: 分层共享 (推荐)

**定义**: 用户级记忆共享，对话级记忆隔离

**实现**:
- **共享层**: User, Entity 节点 (不关联 persona_id)
- **隔离层**: Session 节点 (关联 persona_id)
- **关联**: MENTIONED_IN 关系连接 Entity 和 Session

**Schema 设计**:
```cypher
-- 共享节点
CREATE NODE TABLE User (
    id STRING PRIMARY KEY,
    name STRING,
    platform STRING
)

CREATE NODE TABLE Entity (
    name STRING PRIMARY KEY,
    type STRING,
    description STRING,
    embedding FLOAT[]
)

-- 隔离节点
CREATE NODE TABLE Session (
    id STRING PRIMARY KEY,
    name STRING,
    type STRING,
    persona_id STRING,  -- 关联人格
    created_at TIMESTAMP
)

-- 关联关系
CREATE REL TABLE MENTIONED_IN (
    FROM Entity TO Session,
    mention_count INT64,
    last_mentioned TIMESTAMP
)
```

**示例**:
```
共享记忆 (所有人格可见):
  - User: 张三
  - Entity: Python (技能)
  - Entity: 瑜伽 (爱好)
  - Relation: 张三 -> Python (KNOWS)
  - Relation: 张三 -> 瑜伽 (KNOWS)

隔离记忆 (人格独立):
  - Session1 (tech_assistant): 讨论了 Python 和 Docker
    - Entity: Python -> Session1 (MENTIONED_IN)
    - Entity: Docker -> Session1 (MENTIONED_IN)

  - Session2 (life_advisor): 讨论了瑜伽和冥想
    - Entity: 瑜伽 -> Session2 (MENTIONED_IN)
    - Entity: 冥想 -> Session2 (MENTIONED_IN)
```

**检索逻辑**:
```python
# 检索时同时考虑共享和隔离记忆
async def search_memory(query: str, session_id: str, persona_id: str):
    # 1. 向量搜索所有实体 (共享)
    entities = await vector_search(query)

    # 2. 过滤当前人格相关的实体
    # 方式1: 只返回在当前 persona 的 session 中提及过的实体
    relevant_entities = [
        e for e in entities
        if await is_mentioned_in_persona_sessions(e, persona_id)
    ]

    # 方式2: 返回所有实体，但标注是否在当前 persona 中提及过
    for entity in entities:
        entity.in_current_persona = await is_mentioned_in_persona_sessions(
            entity, persona_id
        )

    return entities
```

**优点**:
- 平衡了连贯性和独立性
- 用户基本信息共享，避免重复
- 对话上下文隔离，避免混淆
- 符合直觉，用户友好

**缺点**:
- 实现稍复杂
- 需要明确定义共享和隔离的边界

**适用场景**:
- 大多数使用场景
- 推荐作为默认策略

### 3.4 策略4: 可配置共享

**定义**: 提供配置项让用户选择共享策略

**配置项**:
```json
{
    "memory_sharing_strategy": "layered",  // "isolated" | "shared" | "layered"
    "shared_entity_types": ["PERSON", "PLACE"],  // 共享的实体类型
    "isolated_entity_types": ["CONCEPT", "EVENT"],  // 隔离的实体类型
    "persona_whitelist": ["tech_assistant", "life_advisor"],  // 白名单
    "persona_blacklist": []  // 黑名单
}
```

**优点**:
- 灵活性最高
- 可以满足各种需求

**缺点**:
- 配置复杂，用户难以理解
- 实现复杂，维护成本高
- 容易出错

**适用场景**:
- 高级用户
- 特殊需求场景

## 四、推荐方案: 分层共享

### 4.1 设计原则

1. **用户信息共享**: 用户的基本信息 (姓名、喜好、技能等) 在所有人格间共享
2. **对话上下文隔离**: 不同人格的对话历史和上下文独立
3. **实体关联灵活**: 实体可以在多个人格的会话中被提及

### 4.2 Schema 设计

```cypher
-- User: 用户节点 (共享)
CREATE NODE TABLE User (
    id STRING PRIMARY KEY,
    name STRING,
    platform STRING,
    created_at TIMESTAMP,
    last_active TIMESTAMP
)

-- Entity: 实体节点 (共享)
CREATE NODE TABLE Entity (
    name STRING PRIMARY KEY,
    type STRING,
    description STRING,
    embedding FLOAT[],
    importance FLOAT DEFAULT 1.0,
    created_at TIMESTAMP,
    last_accessed TIMESTAMP,
    access_count INT64 DEFAULT 0
)

-- Session: 会话节点 (隔离)
CREATE NODE TABLE Session (
    id STRING PRIMARY KEY,
    name STRING,
    type STRING,
    persona_id STRING,  -- 关联人格ID
    created_at TIMESTAMP,
    last_active TIMESTAMP
)

-- PARTICIPATED_IN: 用户参与会话 (共享)
CREATE REL TABLE PARTICIPATED_IN (
    FROM User TO Session,
    role STRING,
    joined_at TIMESTAMP
)

-- RELATED_TO: 实体关系 (共享)
CREATE REL TABLE RELATED_TO (
    FROM Entity TO Entity,
    relation STRING,
    strength FLOAT DEFAULT 1.0,
    evidence TEXT,
    created_at TIMESTAMP,
    last_updated TIMESTAMP
)

-- MENTIONED_IN: 实体在会话中被提及 (隔离)
CREATE REL TABLE MENTIONED_IN (
    FROM Entity TO Session,
    first_mentioned TIMESTAMP,
    last_mentioned TIMESTAMP,
    mention_count INT64 DEFAULT 1,
    sentiment STRING
)

-- KNOWS: 用户了解实体 (共享)
CREATE REL TABLE KNOWS (
    FROM User TO Entity,
    first_known TIMESTAMP,
    last_updated TIMESTAMP,
    familiarity FLOAT DEFAULT 1.0
)
```

### 4.3 检索策略

#### 策略A: 严格隔离 (默认)

只返回在当前人格的会话中提及过的实体。

```python
async def search_memory(
    query: str,
    session_id: str,
    persona_id: str,
    top_k: int = 7
) -> str:
    # 1. 向量搜索所有实体
    all_entities = await vector_search(query, top_k=top_k * 2)

    # 2. 获取当前人格的所有会话
    persona_sessions = await get_sessions_by_persona(persona_id)

    # 3. 过滤: 只保留在当前人格会话中提及过的实体
    relevant_entities = []
    for entity in all_entities:
        for session in persona_sessions:
            if await is_mentioned_in_session(entity.name, session.id):
                relevant_entities.append(entity)
                break
        if len(relevant_entities) >= top_k:
            break

    # 4. 格式化输出
    return format_memory_context(relevant_entities)
```

**优点**: 人格隔离性强，不会出现跨人格的记忆混淆
**缺点**: 可能遗漏相关但未在当前人格提及的实体

#### 策略B: 宽松共享

返回所有相关实体，但标注是否在当前人格中提及过。

```python
async def search_memory(
    query: str,
    session_id: str,
    persona_id: str,
    top_k: int = 7
) -> str:
    # 1. 向量搜索所有实体
    entities = await vector_search(query, top_k=top_k)

    # 2. 获取当前人格的所有会话
    persona_sessions = await get_sessions_by_persona(persona_id)

    # 3. 标注实体是否在当前人格中提及过
    for entity in entities:
        entity.in_current_persona = False
        for session in persona_sessions:
            if await is_mentioned_in_session(entity.name, session.id):
                entity.in_current_persona = True
                break

    # 4. 格式化输出 (优先显示当前人格的实体)
    return format_memory_context(entities, prioritize_current_persona=True)
```

**优点**: 可以利用其他人格的记忆，提供更全面的上下文
**缺点**: 可能出现跨人格的记忆混淆

#### 推荐: 策略A (严格隔离)

理由:
1. 符合人格隔离的设计初衷
2. 避免上下文混淆
3. 用户体验更清晰

### 4.4 实现细节

#### 获取当前人格ID

```python
async def _get_persona_id(self, event: AstrMessageEvent) -> str:
    """获取当前会话使用的人格ID"""
    session_id = event.unified_msg_origin

    # 1. 获取当前对话ID
    cid = await self.context.conversation_manager.get_curr_conversation_id(session_id)
    if not cid:
        return "default"

    # 2. 获取对话信息
    conversation = await self.context.conversation_manager.get_conversation(session_id, cid)
    if not conversation or not conversation.persona_id:
        return "default"

    return conversation.persona_id
```

#### 检测人格切换

```python
async def process_user_message(self, event: AstrMessageEvent):
    """处理用户消息，检测人格切换"""
    session_id = event.unified_msg_origin
    persona_id = await self._get_persona_id(event)

    # 获取上一次的人格ID
    last_persona_id = self.buffer_manager.get_last_persona_id(session_id)

    # 检测人格切换
    if last_persona_id and last_persona_id != persona_id:
        logger.info(
            f"[GraphMemory] 检测到人格切换: {last_persona_id} -> {persona_id}，"
            f"正在刷新缓冲区..."
        )
        # 刷新旧人格的缓冲区
        await self.buffer_manager.flush_buffer(session_id)

    # 添加消息到缓冲区
    await self.buffer_manager.add_user_message(event, persona_id)
```

#### 记忆注入

```python
async def inject_memory(self, event: AstrMessageEvent, req: ProviderRequest):
    """在 LLM 请求前注入相关记忆"""
    session_id = event.unified_msg_origin
    persona_id = await self._get_persona_id(event)

    logger.debug(
        f"[GraphMemory] 为会话 {session_id} 注入记忆 (人格: {persona_id})..."
    )

    # 检索记忆 (只检索当前人格相关的)
    query_embedding = await self.embedding_provider.get_embedding(event.message_str)
    memory_text = await self.graph_store.search_memory(
        query=event.message_str,
        query_embedding=query_embedding,
        session_id=session_id,
        persona_id=persona_id,  # 传入人格ID
        top_k=self.retrieval_top_k
    )

    if memory_text:
        injection = f"\n\n[记忆上下文]\n{memory_text}\n"
        req.system_prompt = (req.system_prompt or "") + injection
```

### 4.5 配置项

采用分层共享策略，不提供人格隔离的开关:

```json
{
    "embedding_provider_id": "必填，Embedding 模型",
    "llm_provider_id": "可选，知识提取模型",
    "enable_group_learning": "是否启用群聊学习",
    "buffer_size_private": "私聊缓冲区大小",
    "buffer_size_group": "群聊缓冲区大小",
    "buffer_timeout": "缓冲区超时时间",
    "enable_query_rewriting": "是否启用查询重写",
    "retrieval_top_k": "检索结果数量",
    "enable_function_calling": "是否启用主动检索",
    "webui_port": "WebUI 端口",
    "webui_key": "WebUI 访问密钥",
    "prune_interval": "图谱维护间隔",
    "time_decay_rate": "时间衰减率",
    "min_importance_threshold": "最小重要性阈值"
}
```

**移除的配置**:
- `enable_persona_isolation`: 默认启用分层共享策略
- `persona_isolation_exceptions`: 不再需要

**说明**:
- 分层共享策略作为默认行为，无需配置
- 用户信息和实体自动共享
- 对话上下文自动隔离
- 检索时自动过滤当前人格相关的记忆

## 五、总结

### 5.1 推荐方案

**分层共享策略**:
- 用户信息和实体共享
- 对话上下文隔离
- 检索时只返回当前人格相关的记忆

### 5.2 关键优势

1. **符合直觉**: 用户信息共享，对话独立
2. **实现简单**: 只需在 Session 节点增加 persona_id
3. **用户友好**: 不需要额外配置
4. **可扩展**: 未来可以增加配置项支持其他策略

### 5.3 实现要点

1. **获取人格ID**: 从 ConversationManager 获取当前对话的 persona_id
2. **检测切换**: 比较当前和上一次的 persona_id
3. **隔离检索**: 检索时过滤当前人格的会话
4. **Session 关联**: Session 节点存储 persona_id

### 5.4 未来扩展

如果用户有特殊需求，可以增加配置项:

```json
{
    "memory_sharing_mode": "layered",  // "isolated" | "shared" | "layered"
    "cross_persona_search": false  // 是否允许跨人格搜索
}
```

但默认情况下，使用分层共享策略即可满足大多数需求。

---

**文档版本**: 1.0
**最后更新**: 2025-01-XX
**状态**: 设计完成
